{
  "rules": [
    {
      "type": "prd",
      "content": "# PRD – Street-Smart Survival Game 랜딩페이지\n\n## 1. 개요\n100명 서바이벌 오프라인 이벤트 “Prove You’re Street Smart” 참가자를 모집하기 위한 반응형 랜딩페이지. 목표는 타깃(MZ 명문대생 & 서바이벌 애청자)의 참가 의향을 검증하고, 이메일·전화번호 리드를 최소 300개 이상 확보하는 것이다.\n\n## 2. 목표 & KPI\n| 목표 | 지표 | 목표치 |\n| --- | --- | --- |\n| 리드 수집 | 제출된 이메일·전화번호 수 | ≥ 300건 / 3주 |\n| 전환율 | 랜딩페이지 방문 → 폼 제출 | ≥ 15% |\n| 공유 유도 | ‘공유’ 버튼 클릭률 | ≥ 10% |\n| 브랜딩 신뢰도 | ‘전문적이다’ UX 서베이(5점) | ≥ 4.0 |\n\n## 3. 핵심 사용자 & 페르소나\n• 에리카(23) – 서울대 재학생, 더 지니어스 애청, 실력 증명 욕구 강함\n• 민수(26) – 연고대 졸업 직장 초년, 명문대생과 겨뤄보고 싶은 도전 욕구\n\n## 4. 주요 기능 (확정)\n1. 간단 신청 폼 (이메일, 전화번호, ‘참가 희망/관심’ 옵션) + CTA\n2. 이벤트 컨셉·규칙·상금 소개 섹션(카피·인포그래픽)\n3. 소셜 공유 버튼(카톡, 인스타, 트위터)\n\n### 기능 상세\n| 기능 | 요구사항 | 우선순위 |\n| --- | --- | --- |\n| 신청 폼 | • 필드: 이름(선택), 이메일(필수), 전화번호(필수)  \n• 제출 시 “대기 리스트 등록 완료” 메시지 + SNS 공유 유도  \n• 데이터는 스프레드시트/DB에 저장 | High |\n| 컨셉·규칙 소개 | • 헤드라인: “명문대생도 울고 갈 궁극의 서바이벌”  \n• 섹션: 컨셉, 5라운드 구조, 상금(100만원+), 네트워킹 포인트  \n• 강렬한 키 비주얼(대형 배너) | High |\n| 소셜 공유 | • 카카오톡·트위터·페이스북·URL 복사  \n• 공유 썸네일/OG 태그 최적화 | Medium |\n| SEO & OG | • SEO 키워드: 서바이벌 게임, 명문대 챌린지 등  \n• OG 이미지/메타 태그 | Medium |\n| 반응형 디자인 | • 모바일 퍼스트, 데스크톱 최적화  \n• 1초 이내 LCP | High |\n\n## 5. 페이지 구조(Information Architecture)\n1. Hero Section – 도발적 헤드라인 + CTA(“지금 지원하고 명문대를 이겨라”)  \n2. Concept Highlight – 게임 설명 인포그래픽  \n3. Prize & Networking – 상금·네트워킹 가치 어필  \n4. Influencer Teaser – 참여 예정 인플루언서 실루엣 카드  \n5. FAQ (Top 3)  \n6. Application Form  \n7. Social Share & Footer\n\n## 6. UX Writing Tone\n• 프리미엄 & 엘리트\n• 도발적: “네가 진짜 실력자라면 보여줘.”\n\n## 7. 비주얼 & 브랜딩 가이드\n• 컬러: Midnight Black (#0D0D0D), Royal Gold(#D4AF37), Crimson Accent(#D7263D)  \n• 폰트: Pretendard Bold/Regular  \n• 이미지: 서바이벌/정장 믹스\n\n## 8. 비기능 요구사항\n| 항목 | 목표 |\n| --- | --- |\n| Performance | Lighthouse Performance ≥ 90 |\n| Accessibility | Lighthouse Accessibility ≥ 90 |\n| Security | HTTPS, reCAPTCHA v2 in form |\n| Analytics | GA4 페이지뷰, 전환 추적 |\n\n## 9. 일정(완성형 빌드)\n| 단계 | 기간 |\n| --- | --- |\n| 디자인 시안 & 카피 확정 | D0 – D+5 |\n| 개발(반응형, OG, GA) | D+6 – D+12 |\n| 테스팅 & 폼 연동 | D+13 – D+15 |\n| 출시 & 홍보 개시 | D+16 |\n\n## 10. 리스크 & 대응\n| 리스크 | 대응 |\n| --- | --- |\n| 리드 전환 저조 | A/B테스트 – 헤드라인·CTA 색상 변경 |\n| 스팸 제출 | 전화번호 형식 검증, reCAPTCHA |\n| 서버 다운 | Netlify/Vercel 정적 호스팅 + 폼백 서비스 |\n\n## 11. 승인\nStakeholder : 프로젝트 오너 “캡틴”  \n승인일 : 2024-XX-XX",
      "writedAt": "2025-08-21T04:39:08.836Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n\n- **Project Overview**: \"Prove You’re Street Smart\" 이벤트 참가자 모집을 위한 반응형 랜딩페이지 개발. Next.js, Supabase, TailwindCSS를 사용하여 빠르고, 확장 가능하며, 시각적으로 매력적인 페이지를 구축한다.\n- **Core Technology Stack**: Next.js (프론트엔드 프레임워크), Supabase (백엔드 서비스), TailwindCSS (CSS 프레임워크)\n- **Key Technical Objectives**: 높은 성능 (Lighthouse Performance ≥ 90), 접근성 (Lighthouse Accessibility ≥ 90), 보안 (HTTPS, reCAPTCHA v2), 높은 전환율 (≥ 15%), 빠른 페이지 로딩 속도 (LCP 1초 이내)\n- **Critical Technical Assumptions**: Netlify 또는 Vercel을 통한 정적 호스팅, 안정적인 Supabase 서비스, GA4 설정 완료.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| Framework         | Next.js                     | 서버 사이드 렌더링 (SSR) 및 정적 사이트 생성 (SSG) 지원, 빠른 초기 로딩 속도, SEO 최적화 |\n| Backend            | Supabase                    | BaaS (Backend as a Service)로, 데이터베이스, 인증, 실시간 기능 제공, 빠른 개발 속도, 비용 효율성 |\n| Styling            | TailwindCSS                 | 유틸리티 우선 CSS 프레임워크, 빠른 스타일링, 반응형 디자인 용이, 유지보수성 향상 |\n| Form Handling      | React Hook Form             | 폼 상태 관리 및 유효성 검사 간소화, 사용자 경험 향상 |\n| HTTP Client        | Axios / Fetch API          | API 요청 및 응답 처리 |\n| Analytics          | Google Analytics 4 (GA4)    | 페이지뷰, 전환 추적, 사용자 행동 분석 |\n| Security           | reCAPTCHA v2                | 폼 제출 스팸 방지 |\n| UI Components      | 자체 개발 또는 Headless UI Components | 프로젝트 디자인 요구 사항에 맞는 UI 컴포넌트 구현 |\n| State Management   | Context API / Zustand       | 전역 상태 관리 (필요한 경우) |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n\n- **Frontend (Next.js)**:\n    - 사용자 인터페이스 (UI) 렌더링 및 사용자 상호 작용 처리\n    - 컴포넌트 기반 아키텍처 (React)\n    - 서버 사이드 렌더링 (SSR) 및 정적 사이트 생성 (SSG)\n    - 서브 블록:\n        - 페이지 컴포넌트 (Hero Section, Concept Highlight, Prize & Networking 등)\n        - UI 컴포넌트 (버튼, 폼, 인포그래픽)\n        - API 클라이언트 (Supabase API 호출)\n- **Backend (Supabase)**:\n    - 데이터베이스 (PostgreSQL)\n    - 인증 (사용자 관리)\n    - API 엔드포인트\n    - 서브 블록:\n        - 데이터베이스 스키마 (이메일, 전화번호 저장)\n        - 인증 규칙 (보안)\n        - API 함수 (데이터 저장, 조회)\n- **Analytics (GA4)**:\n    - 사용자 행동 추적 및 분석\n    - 전환율 측정\n    - 서브 블록:\n        - GA4 스크립트 (페이지에 삽입)\n        - 이벤트 추적 (폼 제출, 버튼 클릭)\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[사용자] --> B(Next.js Frontend)\n    B --> C{Supabase API}\n    C --> D[Supabase Database]\n    B --> E(Google Analytics 4)\n```\n\n- 사용자는 Next.js 프론트엔드와 상호 작용한다.\n- Next.js 프론트엔드는 Supabase API를 통해 데이터를 저장하고 조회한다.\n- Supabase API는 Supabase 데이터베이스와 통신한다.\n- Next.js 프론트엔드는 Google Analytics 4에 사용자 행동 데이터를 전송한다.\n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**\n\n- **Domain Separation**: 랜딩 페이지의 섹션별로 컴포넌트 분리 (Hero, Concept, Prize, Form 등)\n- **Layer-Based Architecture**: UI 컴포넌트, API 호출, 데이터 처리 로직 분리\n- **Feature-Based Modules**: 각 섹션별로 관련된 컴포넌트, 스타일, 로직을 하나의 폴더에 그룹화\n- **Shared Components**: 재사용 가능한 UI 컴포넌트 (버튼, 폼 입력 필드)\n\n**Universal File & Folder Structure**\n\n```\n/\n├── components/             # React 컴포넌트\n│   ├── Hero.js           # Hero 섹션 컴포넌트\n│   ├── Concept.js        # Concept 섹션 컴포넌트\n│   ├── Prize.js          # 상금 섹션 컴포넌트\n│   ├── Form.js           # 신청 폼 컴포넌트\n│   ├── Button.js         # 재사용 가능한 버튼 컴포넌트\n│   └── ...\n├── pages/                  # Next.js 페이지\n│   └── index.js          # 랜딩 페이지\n├── styles/                 # CSS 스타일\n│   ├── globals.css       # 전역 스타일\n│   └── tailwind.config.js  # TailwindCSS 설정\n├── utils/                  # 유틸리티 함수\n│   └── api.js            # Supabase API 클라이언트\n└── public/                 # 정적 파일 (이미지, 폰트)\n    └── images/\n        └── ...\n```\n\n### Data Flow & Communication Patterns\n\n- **Client-Server Communication**: API 요청/응답 패턴 (Next.js Frontend <-> Supabase API)\n- **Database Interaction**: Supabase API를 통해 데이터베이스에 접근 (PostgreSQL)\n- **External Service Integration**: Google Analytics 4 스크립트 삽입\n- **Data Synchronization**: 실시간 데이터 동기화는 필요 없음\n\n## 4. Performance & Optimization Strategy\n\n- 이미지 최적화: 웹P 포맷 사용, 이미지 크기 최적화, Lazy Loading 적용\n- 코드 분할: Next.js의 코드 분할 기능을 사용하여 초기 로딩 속도 향상\n- 캐싱: 정적 자산 캐싱 활용\n- CDN 사용: 이미지 및 정적 자산 CDN 배포\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n\n- **Core Infrastructure**: Next.js 프로젝트 설정, Supabase 연동, TailwindCSS 설정\n- **Essential Features**: Hero 섹션, 컨셉 섹션, 신청 폼 구현, 데이터베이스 연동\n- **Basic Security**: HTTPS 설정, reCAPTCHA v2 적용\n- **Development Setup**: 개발 환경 설정, Git 저장소 생성\n- **Timeline**: D+6 – D+8\n\n### Phase 2: Feature Enhancement\n\n- **Advanced Features**: 상금 섹션, FAQ 섹션, 소셜 공유 기능 구현, GA4 연동\n- **Performance Optimization**: 이미지 최적화, 코드 분할, 캐싱\n- **Enhanced Security**: 폼 유효성 검사 강화\n- **Monitoring Implementation**: GA4 이벤트 추적 설정\n- **Timeline**: D+9 – D+12\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n\n- **Technology Risks**: Supabase 서비스 장애 가능성\n- **Performance Risks**: 페이지 로딩 속도 저하 가능성\n- **Security Risks**: 스팸 제출, 데이터 유출 가능성\n- **Mitigation Strategies**:\n    - Supabase 서비스 장애 대비: 대체 백엔드 서비스 고려\n    - 페이지 로딩 속도 저하 대비: 성능 모니터링, 코드 최적화\n    - 스팸 제출 대비: reCAPTCHA 강화, 전화번호 형식 검증\n    - 데이터 유출 대비: 데이터베이스 보안 강화\n\n### Project Delivery Risks\n\n- **Timeline Risks**: 개발 지연 가능성\n- **Resource Risks**: 개발 인력 부족 가능성\n- **Quality Risks**: 코드 품질 저하 가능성\n- **Deployment Risks**: 배포 실패 가능성\n- **Contingency Plans**:\n    - 개발 지연 대비: 우선순위 조정, 추가 인력 투입\n    - 개발 인력 부족 대비: 외부 개발자 활용\n    - 코드 품질 저하 대비: 코드 리뷰, 자동화 테스트\n    - 배포 실패 대비: 배포 전 테스트, 롤백 전략\n",
      "writedAt": "2025-08-21T04:39:08.836Z"
    },
    {
      "type": "guideline",
      "content": "```markdown\n# Code Guidelines: Street-Smart Survival Game Landing Page\n\n## 1. Project Overview\n\nThis document outlines the coding standards for the \"Prove You’re Street Smart\" landing page. The project utilizes Next.js for the frontend, Supabase for the backend, and TailwindCSS for styling. The primary goal is to create a high-performance, accessible, and visually appealing landing page to gather leads for the event.\n\nKey architectural decisions include Server-Side Rendering (SSR) and Static Site Generation (SSG) with Next.js, a BaaS approach with Supabase, and a utility-first CSS methodology using TailwindCSS.\n\n## 2. Core Principles\n\n*   **Maintainability:** Code should be easy to understand, modify, and debug.\n*   **Performance:** Prioritize fast loading times and efficient rendering.\n*   **Readability:** Code should be clear, concise, and well-documented.\n*   **Testability:** Code should be structured to facilitate unit and integration testing.\n*   **Scalability:** The architecture should accommodate future growth and feature additions.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. JavaScript (Next.js)\n\n*   **File Organization and Directory Structure:** Adhere to the Domain-Driven Organization Strategy as defined in the TRD.\n*   **Import/Dependency Management:** Use absolute imports for components and utilities within the `src` directory (e.g., `import Button from 'components/Button';`). Utilize `npm` or `yarn` for managing dependencies.  Specify exact versions in `package.json` to ensure consistent builds.\n*   **Error Handling Patterns:** Use `try...catch` blocks for handling potential errors in API calls and data processing. Implement error logging with descriptive messages. Consider using a centralized error handling utility.\n\n### 3.2. CSS (TailwindCSS)\n\n*   **File Organization and Directory Structure:** Use Tailwind's utility classes directly in the JSX. Custom CSS (if needed) should be placed in separate modules and imported.\n*   **Class Naming Conventions:** Follow Tailwind's naming conventions for utility classes. Use custom class names sparingly and only when necessary to extend Tailwind's functionality.\n*   **Responsiveness:** Utilize Tailwind's responsive modifiers (e.g., `md:`, `lg:`) to create responsive designs.\n\n### 3.3. Supabase (Backend)\n\n*   **API Interaction:** Use the Supabase JavaScript client library for interacting with the Supabase API.\n*   **Data Modeling:** Define clear and consistent data models for storing event registration information (email, phone number, etc.).\n*   **Security:** Implement row-level security (RLS) policies in Supabase to protect data from unauthorized access.\n\n## 4. Code Style Rules\n\n### 4.1. MUST Follow:\n\n*   **Naming Conventions:**\n    *   **Variables:** Use camelCase for variable names (e.g., `firstName`, `userEmail`).\n    *   **Functions:** Use camelCase for function names (e.g., `handleSubmit`, `fetchData`).\n    *   **Components:** Use PascalCase for component names (e.g., `HeroSection`, `ApplicationForm`).\n    *   **Files:** Use PascalCase for component files (e.g., `HeroSection.js`) and camelCase for utility files (e.g., `api.js`).\n    *   **Rationale:** Consistent naming improves code readability and maintainability.\n\n*   **Component Structure:**\n    *   Components MUST be functional components using React Hooks.\n    *   Components MUST be small and focused on a single responsibility.\n    *   Components MUST receive data via props.\n    *   Rationale: Functional components with Hooks are easier to test and reason about.\n\n*   **Data Fetching:**\n    *   Data fetching MUST be done using `useEffect` hook for component-specific data.\n    *   Centralize API calls in a dedicated `utils/api.js` file.\n    *   Implement loading states to provide feedback to the user during data fetching.\n    *   Rationale: Centralized API calls improve code organization and reusability.\n\n*   **Form Handling:**\n    *   Use `react-hook-form` for form management and validation.\n    *   Define clear validation rules for each form field.\n    *   Provide clear error messages to the user for invalid form inputs.\n    *   Rationale: `react-hook-form` simplifies form handling and validation.\n\n*   **Error Handling:**\n    *   Wrap API calls in `try...catch` blocks to handle potential errors.\n    *   Log errors to the console or a logging service.\n    *   Display user-friendly error messages to the user.\n    *   Rationale: Proper error handling prevents unexpected crashes and improves the user experience.\n\n*   **TailwindCSS Usage:**\n    *   Utilize Tailwind's utility classes for styling.\n    *   Avoid writing custom CSS unless absolutely necessary.\n    *   Use Tailwind's responsive modifiers for creating responsive designs.\n    *   Rationale: TailwindCSS provides a consistent and maintainable styling approach.\n\n*   **Accessibility:**\n    *   Use semantic HTML elements.\n    *   Provide alternative text for images.\n    *   Ensure sufficient color contrast.\n    *   Make the website keyboard navigable.\n    *   Rationale: Accessibility ensures that the website is usable by everyone.\n\n*   **Code Comments:**\n    *   Add comments to explain complex logic or non-obvious code.\n    *   Document component props and function parameters.\n    *   Rationale: Comments improve code readability and maintainability.\n\n### 4.2. MUST NOT Do:\n\n*   **Direct DOM Manipulation:**  Do not directly manipulate the DOM using `document.getElementById` or similar methods. Use React's virtual DOM instead.\n    *   Rationale: Direct DOM manipulation can lead to performance issues and inconsistencies.\n\n*   **Inline Styles:**  Avoid using inline styles. Use TailwindCSS classes instead.\n    *   Rationale: Inline styles are difficult to maintain and override.\n\n*   **Global Variables:**  Do not use global variables. Use React's state management or context API instead.\n    *   Rationale: Global variables can lead to naming conflicts and unexpected behavior.\n\n*   **Complex State Logic in Components:** Avoid implementing complex state logic directly within components. Consider using a state management library like Zustand if necessary.\n    *   Rationale: Keeping components focused on rendering improves testability and maintainability.\n\n*   **Ignoring Accessibility:**  Do not ignore accessibility guidelines.\n    *   Rationale: Accessibility is essential for creating inclusive websites.\n\n*   **Unnecessary Re-renders:**  Avoid causing unnecessary re-renders by carefully managing component dependencies and using `React.memo` when appropriate.\n    *   Rationale: Unnecessary re-renders can negatively impact performance.\n\n*   **Committing commented out code:** Never commit commented out code.\n\n## 5. Architecture Patterns\n\n### 5.1. Component/Module Structure Guidelines\n\n*   **Domain-Driven Design:** Organize components based on the landing page sections (Hero, Concept, Prize, Form).\n*   **Layered Architecture:** Separate UI components, API calls, and data processing logic.\n*   **Feature-Based Modules:** Group related components, styles, and logic into feature folders.\n*   **Shared Components:** Create reusable UI components (Button, Input, etc.) in a `components` directory.\n\n### 5.2. Data Flow Patterns\n\n*   **Unidirectional Data Flow:** Data flows from parent components to child components via props.\n*   **API Requests:** API requests are made from components using the centralized `api.js` utility.\n*   **State Updates:** State updates are triggered by user interactions or API responses.\n\n### 5.3. State Management Conventions\n\n*   **Local State:** Use `useState` for component-specific state.\n*   **Global State (if needed):** Use React's Context API or Zustand for managing global state. Choose Zustand for simplicity and performance if Context API becomes cumbersome.\n*   **State Immutability:** Treat state as immutable and use the spread operator (`...`) to create new state objects.\n\n### 5.4. API Design Standards\n\n*   **RESTful API:** Follow RESTful API principles for interacting with the Supabase backend.\n*   **JSON Format:** Use JSON for request and response bodies.\n*   **Error Handling:** Handle API errors gracefully and provide informative error messages.\n\n## Example Code Snippets\n\n```javascript\n// MUST: Example of a functional component with React Hooks\n// Explanation: This is the preferred way to define components in this project.\nimport React, { useState, useEffect } from 'react';\nimport { useForm } from 'react-hook-form';\nimport { supabase } from 'utils/supabaseClient';\n\nfunction ApplicationForm() {\n  const { register, handleSubmit, formState: { errors } } = useForm();\n  const [loading, setLoading] = useState(false);\n\n  const onSubmit = async (data) => {\n    setLoading(true);\n    try {\n      const { error } = await supabase\n        .from('registrations')\n        .insert([data]);\n\n      if (error) throw error;\n\n      alert('Registration successful!');\n    } catch (error) {\n      console.error('Error submitting form:', error);\n      alert('Registration failed. Please try again.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <label htmlFor=\"email\">Email:</label>\n      <input type=\"email\" id=\"email\" {...register(\"email\", { required: true })} />\n      {errors.email && <span>This field is required</span>}\n\n      <label htmlFor=\"phone\">Phone:</label>\n      <input type=\"tel\" id=\"phone\" {...register(\"phone\", { required: true })} />\n      {errors.phone && <span>This field is required</span>}\n\n      <button type=\"submit\" disabled={loading}>\n        {loading ? 'Submitting...' : 'Submit'}\n      </button>\n    </form>\n  );\n}\n\nexport default ApplicationForm;\n```\n\n```javascript\n// MUST NOT: Example of direct DOM manipulation\n// Explanation: This is not the React way of updating the UI.\n// Instead, use React's state management.\n\nfunction BadComponent() {\n  const handleClick = () => {\n    document.getElementById('myElement').textContent = 'Updated Text!';\n  };\n\n  return (\n    <div>\n      <p id=\"myElement\">Initial Text</p>\n      <button onClick={handleClick}>Update Text</button>\n    </div>\n  );\n}\n\n// CORRECT WAY:\nfunction GoodComponent() {\n  const [text, setText] = useState('Initial Text');\n\n  const handleClick = () => {\n    setText('Updated Text!');\n  };\n\n  return (\n    <div>\n      <p>{text}</p>\n      <button onClick={handleClick}>Update Text</button>\n    </div>\n  );\n}\n```\n\n```javascript\n// MUST: Example of API call using useEffect in a component\n// Explanation: Using useEffect for side effects like API calls ensures proper component lifecycle management.\n\nimport React, { useState, useEffect } from 'react';\nimport { supabase } from 'utils/supabaseClient';\n\nfunction PrizeSection() {\n  const [prizeData, setPrizeData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function fetchPrizeData() {\n      try {\n        const { data, error } = await supabase\n          .from('prizes')\n          .select('*')\n          .limit(1);\n\n        if (error) throw error;\n\n        setPrizeData(data[0]); // Assuming only one prize entry\n        setLoading(false);\n      } catch (err) {\n        setError(err.message);\n        setLoading(false);\n      }\n    }\n\n    fetchPrizeData();\n  }, []); // Empty dependency array ensures this effect runs only once on mount\n\n  if (loading) {\n    return <p>Loading prize information...</p>;\n  }\n\n  if (error) {\n    return <p>Error: {error}</p>;\n  }\n\n  return (\n    <div>\n      {prizeData && (\n        <>\n          <h2>{prizeData.title}</h2>\n          <p>{prizeData.description}</p>\n          <p>Value: {prizeData.value}</p>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default PrizeSection;\n```\n\n```javascript\n// MUST NOT: Example of unnecessary re-renders caused by incorrect dependency array in useEffect\n// Explanation: Incorrect dependency arrays can cause useEffect to run unnecessarily, leading to performance issues.\n\nimport React, { useState, useEffect } from 'react';\n\nfunction IncorrectDependencyComponent({ userId }) {\n  const [userData, setUserData] = useState(null);\n\n  useEffect(() => {\n    // This useEffect will run every time the component re-renders, even if userId hasn't changed.\n    // This is because the dependency array is missing userId.\n    async function fetchUserData() {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      setUserData(data);\n    }\n\n    fetchUserData();\n  }, []); // Incorrect: Empty dependency array\n\n  return (\n    <div>\n      {userData ? <p>User: {userData.name}</p> : <p>Loading...</p>}\n    </div>\n  );\n}\n\n// CORRECT WAY:\nfunction CorrectDependencyComponent({ userId }) {\n  const [userData, setUserData] = useState(null);\n\n  useEffect(() => {\n    // This useEffect will only run when the component mounts or when userId changes.\n    async function fetchUserData() {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      setUserData(data);\n    }\n\n    fetchUserData();\n  }, [userId]); // Correct: userId is included in the dependency array\n\n  return (\n    <div>\n      {userData ? <p>User: {userData.name}</p> : <p>Loading...</p>}\n    </div>\n  );\n}\n```\n\n```tailwind\n// MUST: Example of using TailwindCSS utility classes for responsive design\n// Explanation: This demonstrates how to use responsive prefixes to apply different styles at different screen sizes.\n\n<button className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded md:py-3 md:px-6 lg:text-lg\">\n  Click me\n</button>\n\n//Explanation:\n//bg-blue-500: Sets the background color to blue on smaller screens.\n//hover:bg-blue-700: Changes the background color on hover.\n//text-white: Sets the text color to white.\n//font-bold: Makes the text bold.\n//py-2 px-4: Adds padding.\n//rounded: Rounds the corners.\n//md:py-3 md:px-6: Increases padding on medium screens and up.\n//lg:text-lg: Increases text size on large screens and up.\n```\n```javascript\n// MUST: Example of using a centralized API client (utils/api.js)\n// Explanation: This promotes code reuse and maintainability by centralizing API logic.\n\n// utils/api.js\nimport { supabase } from './supabaseClient'; // Import your Supabase client\n\nexport const getRegistrations = async () => {\n  try {\n    const { data, error } = await supabase\n      .from('registrations')\n      .select('*');\n\n    if (error) {\n      console.error('Error fetching registrations:', error);\n      throw error; // Re-throw the error to be caught by the caller\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Error in getRegistrations:', error);\n    throw error; // Re-throw the error to be caught by the caller\n  }\n};\n\nexport const createRegistration = async (registrationData) => {\n    try {\n      const { data, error } = await supabase\n        .from('registrations')\n        .insert([registrationData]);\n\n      if (error) {\n        console.error('Error creating registration:', error);\n        throw error;\n      }\n\n      return data;\n    } catch (error) {\n      console.error('Error in createRegistration:', error);\n      throw error;\n    }\n  };\n\n\n// In your component:\nimport { getRegistrations, createRegistration } from 'utils/api';\n\nfunction SomeComponent() {\n  const [registrations, setRegistrations] = useState([]);\n\n  useEffect(() => {\n    async function loadRegistrations() {\n      try {\n        const data = await getRegistrations();\n        setRegistrations(data);\n      } catch (error) {\n        console.error('Failed to load registrations:', error);\n        // Handle the error appropriately (e.g., display an error message to the user)\n      }\n    }\n\n    loadRegistrations();\n  }, []);\n\n  const handleRegistrationSubmit = async (data) => {\n    try {\n        await createRegistration(data);\n        // Optionally, refresh the registrations list after successful submission\n        const updatedRegistrations = await getRegistrations();\n        setRegistrations(updatedRegistrations);\n    } catch (error) {\n        console.error('Failed to create registration:', error);\n    }\n  };\n\n  return (\n    <div>\n      {/* Display registrations */}\n    </div>\n  );\n}\n```\n```javascript\n//MUST NOT: Avoid deeply nested components\n//Explanation: Deeply nested components are hard to read and maintain.\n//Bad example\nfunction GrandParentComponent() {\n    return (\n        <div>\n            <ParentComponent>\n                <ChildComponent>\n                    <GrandChildComponent>\n                        Hello World!\n                    </GrandChildComponent>\n                </ChildComponent>\n            </ParentComponent>\n        </div>\n    );\n}\n\n//Good example\nfunction GrandParentComponent() {\n    return (\n        <div>\n            <ParentComponent />\n        </div>\n    );\n}\n\nfunction ParentComponent() {\n    return (\n        <div>\n            <ChildComponent />\n        </div>\n    );\n}\n\nfunction ChildComponent() {\n    return (\n        <div>\n            <GrandChildComponent />\n        </div>\n    );\n}\n\nfunction GrandChildComponent() {\n    return (\n        <div>\n            Hello World!\n        </div>\n    );\n}\n```\nThese guidelines are designed to ensure a consistent, maintainable, and high-quality codebase for the \"Prove You’re Street Smart\" landing page. Adherence to these standards will facilitate collaboration, reduce errors, and improve the overall development process.\n```",
      "writedAt": "2025-08-21T04:39:08.836Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-21T04:39:08.836Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-21T04:39:08.836Z"
    }
  ]
}