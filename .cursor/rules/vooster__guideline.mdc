---
description:
globs:
alwaysApply: true
---
```markdown
# Code Guidelines: Street-Smart Survival Game Landing Page

## 1. Project Overview

This document outlines the coding standards for the "Prove Youâ€™re Street Smart" landing page. The project utilizes Next.js for the frontend, Supabase for the backend, and TailwindCSS for styling. The primary goal is to create a high-performance, accessible, and visually appealing landing page to gather leads for the event.

Key architectural decisions include Server-Side Rendering (SSR) and Static Site Generation (SSG) with Next.js, a BaaS approach with Supabase, and a utility-first CSS methodology using TailwindCSS.

## 2. Core Principles

*   **Maintainability:** Code should be easy to understand, modify, and debug.
*   **Performance:** Prioritize fast loading times and efficient rendering.
*   **Readability:** Code should be clear, concise, and well-documented.
*   **Testability:** Code should be structured to facilitate unit and integration testing.
*   **Scalability:** The architecture should accommodate future growth and feature additions.

## 3. Language-Specific Guidelines

### 3.1. JavaScript (Next.js)

*   **File Organization and Directory Structure:** Adhere to the Domain-Driven Organization Strategy as defined in the TRD.
*   **Import/Dependency Management:** Use absolute imports for components and utilities within the `src` directory (e.g., `import Button from 'components/Button';`). Utilize `npm` or `yarn` for managing dependencies.  Specify exact versions in `package.json` to ensure consistent builds.
*   **Error Handling Patterns:** Use `try...catch` blocks for handling potential errors in API calls and data processing. Implement error logging with descriptive messages. Consider using a centralized error handling utility.

### 3.2. CSS (TailwindCSS)

*   **File Organization and Directory Structure:** Use Tailwind's utility classes directly in the JSX. Custom CSS (if needed) should be placed in separate modules and imported.
*   **Class Naming Conventions:** Follow Tailwind's naming conventions for utility classes. Use custom class names sparingly and only when necessary to extend Tailwind's functionality.
*   **Responsiveness:** Utilize Tailwind's responsive modifiers (e.g., `md:`, `lg:`) to create responsive designs.

### 3.3. Supabase (Backend)

*   **API Interaction:** Use the Supabase JavaScript client library for interacting with the Supabase API.
*   **Data Modeling:** Define clear and consistent data models for storing event registration information (email, phone number, etc.).
*   **Security:** Implement row-level security (RLS) policies in Supabase to protect data from unauthorized access.

## 4. Code Style Rules

### 4.1. MUST Follow:

*   **Naming Conventions:**
    *   **Variables:** Use camelCase for variable names (e.g., `firstName`, `userEmail`).
    *   **Functions:** Use camelCase for function names (e.g., `handleSubmit`, `fetchData`).
    *   **Components:** Use PascalCase for component names (e.g., `HeroSection`, `ApplicationForm`).
    *   **Files:** Use PascalCase for component files (e.g., `HeroSection.js`) and camelCase for utility files (e.g., `api.js`).
    *   **Rationale:** Consistent naming improves code readability and maintainability.

*   **Component Structure:**
    *   Components MUST be functional components using React Hooks.
    *   Components MUST be small and focused on a single responsibility.
    *   Components MUST receive data via props.
    *   Rationale: Functional components with Hooks are easier to test and reason about.

*   **Data Fetching:**
    *   Data fetching MUST be done using `useEffect` hook for component-specific data.
    *   Centralize API calls in a dedicated `utils/api.js` file.
    *   Implement loading states to provide feedback to the user during data fetching.
    *   Rationale: Centralized API calls improve code organization and reusability.

*   **Form Handling:**
    *   Use `react-hook-form` for form management and validation.
    *   Define clear validation rules for each form field.
    *   Provide clear error messages to the user for invalid form inputs.
    *   Rationale: `react-hook-form` simplifies form handling and validation.

*   **Error Handling:**
    *   Wrap API calls in `try...catch` blocks to handle potential errors.
    *   Log errors to the console or a logging service.
    *   Display user-friendly error messages to the user.
    *   Rationale: Proper error handling prevents unexpected crashes and improves the user experience.

*   **TailwindCSS Usage:**
    *   Utilize Tailwind's utility classes for styling.
    *   Avoid writing custom CSS unless absolutely necessary.
    *   Use Tailwind's responsive modifiers for creating responsive designs.
    *   Rationale: TailwindCSS provides a consistent and maintainable styling approach.

*   **Accessibility:**
    *   Use semantic HTML elements.
    *   Provide alternative text for images.
    *   Ensure sufficient color contrast.
    *   Make the website keyboard navigable.
    *   Rationale: Accessibility ensures that the website is usable by everyone.

*   **Code Comments:**
    *   Add comments to explain complex logic or non-obvious code.
    *   Document component props and function parameters.
    *   Rationale: Comments improve code readability and maintainability.

### 4.2. MUST NOT Do:

*   **Direct DOM Manipulation:**  Do not directly manipulate the DOM using `document.getElementById` or similar methods. Use React's virtual DOM instead.
    *   Rationale: Direct DOM manipulation can lead to performance issues and inconsistencies.

*   **Inline Styles:**  Avoid using inline styles. Use TailwindCSS classes instead.
    *   Rationale: Inline styles are difficult to maintain and override.

*   **Global Variables:**  Do not use global variables. Use React's state management or context API instead.
    *   Rationale: Global variables can lead to naming conflicts and unexpected behavior.

*   **Complex State Logic in Components:** Avoid implementing complex state logic directly within components. Consider using a state management library like Zustand if necessary.
    *   Rationale: Keeping components focused on rendering improves testability and maintainability.

*   **Ignoring Accessibility:**  Do not ignore accessibility guidelines.
    *   Rationale: Accessibility is essential for creating inclusive websites.

*   **Unnecessary Re-renders:**  Avoid causing unnecessary re-renders by carefully managing component dependencies and using `React.memo` when appropriate.
    *   Rationale: Unnecessary re-renders can negatively impact performance.

*   **Committing commented out code:** Never commit commented out code.

## 5. Architecture Patterns

### 5.1. Component/Module Structure Guidelines

*   **Domain-Driven Design:** Organize components based on the landing page sections (Hero, Concept, Prize, Form).
*   **Layered Architecture:** Separate UI components, API calls, and data processing logic.
*   **Feature-Based Modules:** Group related components, styles, and logic into feature folders.
*   **Shared Components:** Create reusable UI components (Button, Input, etc.) in a `components` directory.

### 5.2. Data Flow Patterns

*   **Unidirectional Data Flow:** Data flows from parent components to child components via props.
*   **API Requests:** API requests are made from components using the centralized `api.js` utility.
*   **State Updates:** State updates are triggered by user interactions or API responses.

### 5.3. State Management Conventions

*   **Local State:** Use `useState` for component-specific state.
*   **Global State (if needed):** Use React's Context API or Zustand for managing global state. Choose Zustand for simplicity and performance if Context API becomes cumbersome.
*   **State Immutability:** Treat state as immutable and use the spread operator (`...`) to create new state objects.

### 5.4. API Design Standards

*   **RESTful API:** Follow RESTful API principles for interacting with the Supabase backend.
*   **JSON Format:** Use JSON for request and response bodies.
*   **Error Handling:** Handle API errors gracefully and provide informative error messages.

## Example Code Snippets

```javascript
// MUST: Example of a functional component with React Hooks
// Explanation: This is the preferred way to define components in this project.
import React, { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { supabase } from 'utils/supabaseClient';

function ApplicationForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();
  const [loading, setLoading] = useState(false);

  const onSubmit = async (data) => {
    setLoading(true);
    try {
      const { error } = await supabase
        .from('registrations')
        .insert([data]);

      if (error) throw error;

      alert('Registration successful!');
    } catch (error) {
      console.error('Error submitting form:', error);
      alert('Registration failed. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <label htmlFor="email">Email:</label>
      <input type="email" id="email" {...register("email", { required: true })} />
      {errors.email && <span>This field is required</span>}

      <label htmlFor="phone">Phone:</label>
      <input type="tel" id="phone" {...register("phone", { required: true })} />
      {errors.phone && <span>This field is required</span>}

      <button type="submit" disabled={loading}>
        {loading ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}

export default ApplicationForm;
```

```javascript
// MUST NOT: Example of direct DOM manipulation
// Explanation: This is not the React way of updating the UI.
// Instead, use React's state management.

function BadComponent() {
  const handleClick = () => {
    document.getElementById('myElement').textContent = 'Updated Text!';
  };

  return (
    <div>
      <p id="myElement">Initial Text</p>
      <button onClick={handleClick}>Update Text</button>
    </div>
  );
}

// CORRECT WAY:
function GoodComponent() {
  const [text, setText] = useState('Initial Text');

  const handleClick = () => {
    setText('Updated Text!');
  };

  return (
    <div>
      <p>{text}</p>
      <button onClick={handleClick}>Update Text</button>
    </div>
  );
}
```

```javascript
// MUST: Example of API call using useEffect in a component
// Explanation: Using useEffect for side effects like API calls ensures proper component lifecycle management.

import React, { useState, useEffect } from 'react';
import { supabase } from 'utils/supabaseClient';

function PrizeSection() {
  const [prizeData, setPrizeData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchPrizeData() {
      try {
        const { data, error } = await supabase
          .from('prizes')
          .select('*')
          .limit(1);

        if (error) throw error;

        setPrizeData(data[0]); // Assuming only one prize entry
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchPrizeData();
  }, []); // Empty dependency array ensures this effect runs only once on mount

  if (loading) {
    return <p>Loading prize information...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      {prizeData && (
        <>
          <h2>{prizeData.title}</h2>
          <p>{prizeData.description}</p>
          <p>Value: {prizeData.value}</p>
        </>
      )}
    </div>
  );
}

export default PrizeSection;
```

```javascript
// MUST NOT: Example of unnecessary re-renders caused by incorrect dependency array in useEffect
// Explanation: Incorrect dependency arrays can cause useEffect to run unnecessarily, leading to performance issues.

import React, { useState, useEffect } from 'react';

function IncorrectDependencyComponent({ userId }) {
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    // This useEffect will run every time the component re-renders, even if userId hasn't changed.
    // This is because the dependency array is missing userId.
    async function fetchUserData() {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      setUserData(data);
    }

    fetchUserData();
  }, []); // Incorrect: Empty dependency array

  return (
    <div>
      {userData ? <p>User: {userData.name}</p> : <p>Loading...</p>}
    </div>
  );
}

// CORRECT WAY:
function CorrectDependencyComponent({ userId }) {
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    // This useEffect will only run when the component mounts or when userId changes.
    async function fetchUserData() {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      setUserData(data);
    }

    fetchUserData();
  }, [userId]); // Correct: userId is included in the dependency array

  return (
    <div>
      {userData ? <p>User: {userData.name}</p> : <p>Loading...</p>}
    </div>
  );
}
```

```tailwind
// MUST: Example of using TailwindCSS utility classes for responsive design
// Explanation: This demonstrates how to use responsive prefixes to apply different styles at different screen sizes.

<button className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded md:py-3 md:px-6 lg:text-lg">
  Click me
</button>

//Explanation:
//bg-blue-500: Sets the background color to blue on smaller screens.
//hover:bg-blue-700: Changes the background color on hover.
//text-white: Sets the text color to white.
//font-bold: Makes the text bold.
//py-2 px-4: Adds padding.
//rounded: Rounds the corners.
//md:py-3 md:px-6: Increases padding on medium screens and up.
//lg:text-lg: Increases text size on large screens and up.
```
```javascript
// MUST: Example of using a centralized API client (utils/api.js)
// Explanation: This promotes code reuse and maintainability by centralizing API logic.

// utils/api.js
import { supabase } from './supabaseClient'; // Import your Supabase client

export const getRegistrations = async () => {
  try {
    const { data, error } = await supabase
      .from('registrations')
      .select('*');

    if (error) {
      console.error('Error fetching registrations:', error);
      throw error; // Re-throw the error to be caught by the caller
    }

    return data;
  } catch (error) {
    console.error('Error in getRegistrations:', error);
    throw error; // Re-throw the error to be caught by the caller
  }
};

export const createRegistration = async (registrationData) => {
    try {
      const { data, error } = await supabase
        .from('registrations')
        .insert([registrationData]);

      if (error) {
        console.error('Error creating registration:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Error in createRegistration:', error);
      throw error;
    }
  };


// In your component:
import { getRegistrations, createRegistration } from 'utils/api';

function SomeComponent() {
  const [registrations, setRegistrations] = useState([]);

  useEffect(() => {
    async function loadRegistrations() {
      try {
        const data = await getRegistrations();
        setRegistrations(data);
      } catch (error) {
        console.error('Failed to load registrations:', error);
        // Handle the error appropriately (e.g., display an error message to the user)
      }
    }

    loadRegistrations();
  }, []);

  const handleRegistrationSubmit = async (data) => {
    try {
        await createRegistration(data);
        // Optionally, refresh the registrations list after successful submission
        const updatedRegistrations = await getRegistrations();
        setRegistrations(updatedRegistrations);
    } catch (error) {
        console.error('Failed to create registration:', error);
    }
  };

  return (
    <div>
      {/* Display registrations */}
    </div>
  );
}
```
```javascript
//MUST NOT: Avoid deeply nested components
//Explanation: Deeply nested components are hard to read and maintain.
//Bad example
function GrandParentComponent() {
    return (
        <div>
            <ParentComponent>
                <ChildComponent>
                    <GrandChildComponent>
                        Hello World!
                    </GrandChildComponent>
                </ChildComponent>
            </ParentComponent>
        </div>
    );
}

//Good example
function GrandParentComponent() {
    return (
        <div>
            <ParentComponent />
        </div>
    );
}

function ParentComponent() {
    return (
        <div>
            <ChildComponent />
        </div>
    );
}

function ChildComponent() {
    return (
        <div>
            <GrandChildComponent />
        </div>
    );
}

function GrandChildComponent() {
    return (
        <div>
            Hello World!
        </div>
    );
}
```
These guidelines are designed to ensure a consistent, maintainable, and high-quality codebase for the "Prove Youâ€™re Street Smart" landing page. Adherence to these standards will facilitate collaboration, reduce errors, and improve the overall development process.
```
